package com.pbe;

import jdk.swing.interop.SwingInterOpUtils;

import java.util.InputMismatchException;
import java.util.NoSuchElementException;
import java.util.Scanner;

/** Study on Java Exception Handling
 @author Pieter Beernink
 @version 1.0
 @since 1.0
 */

// *********************
// EXCEPTION HANDLING
// *********************
// An exception is an unexpected event occurring during the execution of a program and as such disrupting the normal flow of instructions.
// The main goal of exception handling is to prevent disruption and maintain a controlled flow of the program.

// Two main approaches in dealing with errors:
// 1. LBYL - Look Before You Leave
// 2. EAFP - Easier to Ask for Forgiveness then Permission
// In Java, LBYL is most common. To test if an object is not null for example, before using it.
// In EAFP you perform the operation and then respond to the exception if something goes wrong.

// Exception handling is managed via five keywords:
// 1. try - used to contain program statements to monitor for exceptions; must be followed by either catch or finally
// 2. catch (=exception handler) - used to catch one or more 'thrown' exceptions that may occur in the try block; must be preceded by try block and can be followed by a finally block
// note: it's essential to make sure that any code in the catch statement doesn't cause any exceptions itself
// 3. throw - to manually throw an exception
// 4. throws - to specify exceptions that can occur in a method; i.e. it doesn't throw exceptions, it just specifies those that may occur
// 5. finally - optional, specifies any code that absolutely must be executed after a try block completes and executes no matter if an exception is handled or not

// Whenever an exceptional condition (error) arises, an object representing that exception is created and 'thrown' (in the method that caused the error).
// That method than either handles the exception itself or passes it on. Next, at some point the exception is 'caught' and processed.

// Exceptions are broadly categorized into two sections:
// 1. Checked exceptions (or 'compile time exceptions', as they are checked by the compiler)
//    These are considered error scenarios which are outside the immediate control of the program.
//    Occurring usually when interacting with other systems/resources, resulting in database errors, network connection errors, missing files etc.
//    All checked exceptions are subclasses of Exception class.
//    Examples of checked exceptions: ClassNotFoundException, IOException, SQLException, IllegalAccessException
// 2. Unchecked exceptions
//    These are runtime exceptions (and thus not checked by the compiler) occurring during use of the program.
//    Standard package java.lang defines several exception classes. The most general of these exceptions are subclasses of RunTimeException.
//    As the compiler does not check to see if a method handles or throws these exceptions, these exceptions are not to be included in any method's throw list.
//    Examples of unchecked exceptions: ArithmeticException, ArrayStoreException, ClassCastException, IndexOutOfBounds, NullPointerException

// A third type of exception is an Error. Errors are irrecoverable, such as OutOfMemoryError, VirtualMachineError or an AssertionError.

// I.e. exceptions can be generated by 1) te Java run-time system or 2) manually generated by own code:
// - Exceptions thrown by Java relate to errors that violate the rules of Java or the constraints of Java execution environment.
// - Exceptions thrown by own code are typically used to report some error condition to the caller of a method.

// In Java, all exception types are subclasses of the build-in class Throwable
// Throwable is at the topic of the exception class hierarchy and branches in two subclasses:
// 1. Exception - Used for exceptional conditions that user programs should catch. It has a subclass RuntimeException. Exceptions of this type are automatically defined.
// 2. Error - used by the Java run-time system for errors that have to do with the run-time environment, such as a stack overflow.

// When an error occurs within a method, the method creates an object (or any subtype of Throwable) and hands it off to the runtime system.
// This object is called the exception object. If it's handled by the program (with a try/catch), the rest of code will be executed and a controlled flow is maintained.
// If it's not handled, Java default handler will:
// 1. Display a string describing the exception
// 2. Print a stack trace from the point at which the exception occurred
// 3. Terminate the program

// The total generated exception 'stack trace' will contain: 1) the class name, 2) method name, 3) filename and 4) line number of the exception
// The stack trace will always show the sequence of method invocations that led up to the error.
// This is useful for debugging as it pinpoints the precise sequence of steps that led to the error.

// Besides Java run-time system default exception handler, it's possible -and usually preferred- to handle an exception by the program itself.
// This 1) provides an opportunity to fix the error and 2) prevents the program from automatically terminating

// It's possible to create own exception types to handle situations specific to an own application.
// To do so, a subclass of Exception (= subclass of Throwable) must be defined.
// These subclasses don't need to implement anything. Their existence in the type system allows them to be used as exceptions.
// All exceptions, including own creations, have the methods defined by Throwable available to them (which can be overridden).
// Check methods defined by Throwable for more info.

// Exception defines four public constructors:
// 1. Exception() - creates an exception without description
// 2. Exception(String msg) - allows for a message to be specified
// Sometimes it's better to override toString() instead, to prevent the exception name and colon from being displayed, for cleaner output,
// 3 & 4 Chained exceptions - allows to associate another exception with an exception, with the second exception describing the cause of the first exception

// Exception handling best practices
// Checked exceptions ideally aren't used for programming errors, but definitely used for resource errors and for flow control in such cases.
// Only throw those exceptions which a method can't handle by any mean.
// For clear method signatures, declare exceptions close to method name. For example openFile() method -> FileNotFoundException
// If a client can reasonably be expected to recover from an exception, make it a checked exception.
// If a client cannot do anything to recover from the exception, make it an unchecked exception.

// Assertions / use of assert
// NOTE: Not to be used as exception handling solution, but as it somewhat relates in preventing errors, decided to add under the Exceptions topic.
//
// Keyword assert is used during program development to create 'an assertion'.
// Assertions are used to verify that some expected condition is actually met.
// I.e. it enables you to test your assumptions about your program.
// For example: to test if a method that should always return a positive value, actually is.
// This is done by asserting that the return value is greater than zero using an assert statement.
// Or with a method that calculates the speed of a particle, it might be asserted that the calculated speed is less than the speed of light.
//
// Two forms of the assert keyword:
// 1. assert condition
// Here, condition is an expression that evaluates to an boolean result. If true, no other action takes place. Otherwise, an AssertionError is thrown.
// 2. assert condition: expr;
// Expr is a value passed to the AssertionError constructor and is converted to its string format and displayed if an assertion fails.
// Typically a string is specified for expr, but any non-void expression is allowed as long as it results in a string conversion.
// By verifying that the boolean expression is true, the assertion confirms the assumptions about the behavior of the program.
// This increases the confidence that the program is free of errors.
//
// Using assertions is one of the quickest and most effective ways to detect and correct bugs.
// Assertions can also serve to document the inner workings of your program, enhancing maintainability.
// Assertions are a development-phase tool to catch bugs in the code.
// They're to be used internal checks to make sure that any made assumptions are correct.
// They're designed to be easily removed when no longer needed.
//
// There are many situations where it is good to use assertions, including (see oracle docs):
// - Internal Invariants
// - Control-Flow Invariants
// - Preconditions, Postconditions, and Class Invariants
//
// Situations where not to use them:
// - For argument checking in public methods
// Argument checking is typically part of the published specs/contract of a method, which must be obeyed no matter if assertions are enabled or disabled
// - To do any work that your application requires for correct operation.
// Assertions are not meant to be used in production, where use of assertions should be disabled.

// To enable assertion checking at run time, it's required to specify -ea option when running java.
// For this reason, assertions should never be relied on to perform any action actually required by the program, as normally a program will not be run with assertions enabled.
// Assertions can also be disabled by using the -da option.

public class Main {

    static int val = 3;

    public static void main(String[] args) {

        // Some common scenarios of Java exceptions:
        // 1. Dividing a number by zero results in an ArithmeticException
        // int a = 1/0;
        // 2. Performing an operation on a variable that has a null value results in a NullPointerException
        // String s = null;
        // System.out.println(s.length());
        // 3. Wrong formatting of a value may result in a NumberFormatException
        // String s = "xyz";
        // int i = Integer.parseInt(s);
        // Inserting a value in an index that does not exist results in an ArrayIndexOutOfBoundsException
        // int a[] = { 1, 2, 3 };
        // a[10] = 11;


        // Example of LBYL: Look Before You Leave
        // Example of EAFP: Easier to Ask for Forgiveness then Permission
        int x = 98;
        int y = 0;
        System.out.println(divideLBYL(x, y));
        System.out.println(divideEAFP(x, y));
        System.out.println();

        // Example of a divide by zero error, not being handled
        System.out.println("Division by zero error, without own exception handling");
        System.out.println("-------------------------------------------");
//        int a = 0;
//        int b = 10 / 0; // will cause a 'ArithmeticException: / by zero' error
        System.out.println();

        // Example of a divide by zero error, with try & catch
        // Try and catch form a unit. Once an exception is thrown, the program control transfers out of the try block into the catch block.
        // From a catch, execution never returns to the try block.
        // Goal of a try-catch is to resolve an exceptional condition and continue on as if the error never happened.
        // Exceptions are returned with a string that contains a description of the exception, that can be displayed.
        // Or an own exception description can be displayed.
        // NOTE: variables introduced in the try block, only exist within that block
        System.out.println("Division by zero error, with try and (matching) catch");
        System.out.println("-------------------------------------------");
        try {
            int a = 0;
            int b = 10 / 0; // will cause a 'ArithmeticException: / by zero' error
            System.out.println("This line will not be executed."); // if an error occurs in the try block, the rest of the block code is not executed
        } catch (ArithmeticException e) {
            System.out.println("Exception: " + e); // this will display the string containing a description of the exception
            System.out.println("Division by zero."); // alternatively: use an own description
        }
        System.out.println("After try/catch \n");

        // Example of try & catch with a different type of exception class
        // An "/ by zero" exception is caused, but there's no matching catch provided.
        // This will cause the program to terminate.
//        System.out.println("Division by zero error, with try and (non matching) catch");
//        System.out.println("-------------------------------------------");
//        try {
//            int a = 0;
//            int b = 10 / 0; // will cause a 'ArithmeticException: / by zero' error
//            System.out.println("This line will not be executed.");
//        } catch (ArrayIndexOutOfBoundsException  e) { // not a matching catch with the caused exception
//            System.out.println("Exception: " + e);
//        }
//        System.out.println("After try/catch \n");

        // Example of multiple catch clauses
        // In some cases, it's useful/required to catch multiple exceptions
        // For this purpose, two or more catch clauses can be used, each catching a different exception
        // Each catch block must contain a different exception handler
        // With an exception thrown, each catch statement is inspected one after another
        // The catch statement which type matches first, will be executed, bypassing the others
        // Execution then continues after the try / catch block
        System.out.println("Multiple catch clauses");
        System.out.println("-------------------------------------------");
        try {
            int a = args.length; // will result in a = 0 if no command line arguments are provided at program start
            int b = 10 / a; // causing a '/ zero' exception
            int c[] = {1, 2, 3};
            c[10] = 11; // causing an 'out of bounds' exception as c[] consists of only 3 elements
        } catch (ArithmeticException e) {
            System.out.println("Divide by 0: " + e);
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Array index oob: " + e); // program will only get to this point if args are provided (read: if a > 0)
        }
        System.out.println("After try/catch blocks \n");

        // With multiple catch statements, subclasses must come before any of their superclasses
        // Because a catch statement that uses a superclass, will catch exceptions of that type PLUS any of its subclasses
        // A subclass would never be reached if it came after its superclass
        // Put differently: all catch blocks must be ordered from most specific to most general
        // I.e. catch for ArithmeticException must come before catch for Exception.
        // Note: in Java, unreachable code is an error
        System.out.println("Multiple catch clauses: subclass must come before its superclass");
        System.out.println("-------------------------------------------");
        try {
            int a[] = new int[5];
            a[5] = 2/0;
        } catch(ArrayIndexOutOfBoundsException e) {
            System.out.println("ArrayIndexOutOfBounds Exception occurs");
        } catch (Exception e) { // handling the exception by using Exception class, instead of a specific subclass
            System.out.println("Generic Exception catch");
        }
//        catch (ArithmeticException e) {
//            System.out.println("Arithmetic Exception occurs. This line will never be reached");
//            As ArithmeticException is a subclass of exception, this catch line is unreachable and will be causing an error
//            This is because the general exception catch has already caught the exception.
//            This problem can be fixed by switching the catch statements, with the ArithmeticException catch coming prior to the general Exception catch.
//        }
        System.out.println("rest of the code \n");

        // Example of multiple exceptions in a single catch block
        System.out.println("Multiple exceptions in a single catch block");
        try {
            int result = divide();
        } catch (ArithmeticException | NoSuchElementException e) { // use | to be able to list multiple exceptions in a single catch line
            System.out.println(e.toString()); // toString prints the error message
            System.out.println("Unable to perform division, shutting down...");
        }

        // Example of nested try statement
        // A try statement can be inside the block of another try.
        // This is useful for situations where a part of a block may cause one error and the entire block itself may cause another error.
        // In such cases, exception handlers should be nested.
        // Each try statement will be passed and the context of each exception added on the stack.
        // If a try statement does not have a catch handler for a particular exception, the next try statement's catch handler is checked for a match.
        // If none of the catch statements matches, Java run-time system will handle the exception.
        // In below example, set a to 0, 1 or 2, to get different exceptions
        System.out.println("Nested try statement");
        System.out.println("-------------------------------------------");
        try {
            int a = 0;
            int b = 1 / a; // causing '/ zero' exception if a = 0
            try { // NESTED TRY !
                if (a == 1)
                    a = a / (a - a);  // causing another '/ zero' exception
                if (a == 2) {
                    int c[] = {1};
                    c[10] = 11; // causing 'out of bounds' exception
                }
            } catch (ArrayIndexOutOfBoundsException e) { // first catch in nested try
                System.out.println("Array index out-of-bounds: " + e);
            } catch (ArithmeticException e) { // second catch in nested try
                System.out.println("Divide by 0: " + e);
            }
        } catch (ArithmeticException e) { // catch in main try
            System.out.println("Divide by 0: " + e);
        }
        System.out.println();

        // Example of nested try statement, with method call
        // A call to a method can be enclosed within a try block
        // Inside the method can be another (nested) try statement
        // The try within the method is nested inside the try block that called the method
        System.out.println("Nested try statement, with method call");
        System.out.println("-------------------------------------------");
        try {
            int a = 0;
            int b = 1 / a; // causing '/ zero' exception if a = 0
            nesttry(a);
        } catch (ArithmeticException e) {
            System.out.println("Divide by 0: " + e);
        }

        // Example of throwing own exception (throw)
        // With use of the throw statement a program can throw an exception explicitly: 'throw ThrowableInstance'
        // ThrowableInstance must be an object of type Throwable or a subclass
        // Primitive types (int, char, ..) and non-Throwable classes (String, Object, ..) can't be used as exception
        // Two ways to obtain a Throwable object:
        // 1. Using a parameter in a catch clause
        // 2. Creating one with the new operator
        // The flow of execution stops immediately after the throw statement. No further statements are executed.
        // The (nested) try block(s) are inspected to see if there's a catch statement that matches.
        // If no matching catch is found, Java default exception handler takes care.
        System.out.println("Another throw example");
        System.out.println("-------------------------------------------");
        try {
            throwtest(); // calling method that will throw and catch a NullPointer exception
        } catch (NullPointerException e) { // the exception is caught again
            System.out.println("throw exception caught again: " + e + "\n");
        }

        // Example of throws
        // A 'throws' clause can be used in a method's declaration to list the types of exceptions that the method is capable to cause, but does not handle.
        // It provides information to the caller of the method about the possible exceptions.
        // This way, callers of the method can guard themselves against these possible exceptions so that normal flow in the program can be maintained.
        // The throws clause specifies an exception list; a comma-seperated list of the exceptions that the applicable method can throw.
        System.out.println("Throws example");
        System.out.println("-------------------------------------------");
        try {
            throwsException();
        } catch (IllegalAccessException e) {
            System.out.println("Caught: " + e + "\n");
        }

        // Example of use of finally keyword
        // Thrown exceptions causes the execution flow in a method to be abruptly altered. Potentially causing it to return prematurely.
        // The 'finally' keyword can be used to create a block of code that will be executed after a try/catch block has completed,
        // ...and before the code following the try/catch block.
        // The finally block will execute whether or not an exception is thrown or handled. Even if no matching catch statement is present.
        // This is useful for example to close an open connection or stream.
        // The finally clause is optional (although note that each try statement requires at least a catch OR finally clause)
        System.out.println("Finally example");
        System.out.println("-------------------------------------------");
        try {
            methodA(); // throws and catches an exception: prematurely breaking out of try and executes finally on it's way out
            throw new RuntimeException("demo");
        } catch (Exception e) {
            System.out.println("Exception caught: " + e);
        }
        methodB(); // exits try block via a return statement and executes finally on it's way out
        methodC(); // executes try/catch block without issues and executes finally on it's way out
        System.out.println();

        // Example of declaring own subclass of Exception
        // This example declares a new subclass of Exception to use it to signal an error condition in a method.
        // It overrides toString(), ti display a tailored description of the exception.
        System.out.println("Declaring an Exception subclass");
        // see ExceptionDemo class
        System.out.println();

        // Chained exceptions
        // It's possible to associate one exception with another, with the second exception describing the cause of the first exception.
        // This is called chained exceptions.
        // T.B.D.

        // Additional exception features
        // Since JDK7 there are three additional features that are part of the exception system:
        // 1. try-with-resources
        // 2. multi-catch
        // 3. final rethrow / more precise rethrow
        // T.B.D.

        // **********************
        // Demonstration of assert
        // **********************
        // To enable assertion checking at run time, it's needed to start java with having the -ea option specified
        // Without -ea, assertion checking will not take place and no exception will be thrown.
        System.out.println("Example of using assert");
        int n;
        for (int i=0; i < 5; i++) {
            n = getnum(); // calls getnum, which returns an integer value, which is assigned to n
            assert n > 0; // n is tested to be > 0 and fails when n is 0, causing an AssertionError exception
            // assert n > 0 : "n is not > 0"; // assertion with own specific exception message
            System.out.println("n is: " + n);
        }
    }

    // ************************
    // FOLLOWING: METHODS USED IN EXAMPLES
    // ************************

    // Example of LBYL: Look Before You Leave
    private static int divideLBYL(int x, int y) {
        if(y != 0) {
            return x / y;
        } else {
            return 0;
        }
    }

    // Example of EAFP: Easier to Ask for Forgiveness then Permission
    private static int divideEAFP(int x, int y) {
        try {
            return x / y;
        } catch (ArithmeticException e) {
            return 0;
        }
    }

    // Example of LBYL: Look Before You Leave
    private static int getIntLBYL() {
        Scanner s = new Scanner(System.in);
        boolean isValid = true;
        System.out.println("Please enter an integer ");
        String input = s.next();
        for(int i=0; i<input.length(); i++) {
            if(!Character.isDigit(input.charAt(i))) { // checking up front if input is valid
                isValid = false;
                break;
            }
        }
        if(isValid) { // input is valid, pass value back
            return Integer.parseInt(input);
        }
        return 0;
    }

    // Example of EAFP: Easier to Ask for Forgiveness then Permission
    private static int getIntEAFP() {
        Scanner s = new Scanner(System.in);
        System.out.println("Please enter an integer ");
        try { // testing the user input
            return s.nextInt();
        } catch (InputMismatchException e) { // catching exception on input
            return 0;
        }
    }


    //
    private static int divide() {
        int x, y;
//        try {
            x = getInt();
            y = getInt();
            System.out.println("x is " + x + ", y is " + y);
            return x / y;
//        } catch (NoSuchElementException e) {
//            throw new ArithmeticException("No suitable input");
//        } catch (ArithmeticException e) {
//            throw new ArithmeticException("atempt to divide by zero");
//        }
    }

    // not to be used normally like this, just for example purposes
    private static int getInt() {
        Scanner s = new Scanner(System.in);
        System.out.println("Please enter an integer");
        while(true) {
            try {
                return s.nextInt();
            } catch (InputMismatchException e) {
                // go round again, reading past the end of line in the input first
                s.nextInt();
                System.out.println("Please enter a number using only the digits 0 to 9");
            }
        }
    }

    // Method used in example to demonstrate use of a nested try statement, with method call
    static void nesttry(int a) {
        try { // NESTED TRY !
            System.out.println("try in nest-try() called");
            if (a == 1)
                a = a / (a - a);  // causing another '/ zero' exception
            if (a == 2) {
                int c[] = {1};
                c[10] = 11; // causing 'out of bounds' exception
            }
        } catch (ArrayIndexOutOfBoundsException e) { // first catch in nested try
            System.out.println("Array index out-of-bounds: " + e);
        }
    }

    // Method used in example to demonstrate use of throw
    static void throwtest() {
        try {
            throw new NullPointerException("throw test"); // throw exception - notice 'new' here creates an instance of NullPointerException
        } catch (NullPointerException e) { // catch exception
            System.out.println("exception caught inside throwtest()");
            throw e; // rethrow the exception
        }
    }

    // Method used in example to demonstrate use of throws
    static void throwsException() throws IllegalAccessException {
        System.out.println("Inside causeException()");
        throw new IllegalAccessException("demonstration");
    }

    // Method used in example to demonstrate finally keyword
    // Throw an exception out of a method
    static void methodA() {
        try {
            System.out.println("inside methodA()");
            throw new RuntimeException("demo");
        } finally {
            System.out.println("A's finally");
        }
    }

    // Method used in example to demonstrate finally keyword
    // Return from within a try block
    static void methodB() {
        try {
            System.out.println("inside methodB()");
            //throw new RuntimeException("demo");
            return;
        } finally {
            System.out.println("B's finally");
        }
    }

    // Method used in example to demonstrate finally keyword
    // Execute a try block normally
    static void methodC() {
        try {
            System.out.println("inside methodC()");
        } finally {
            System.out.println("C's finally");
        }
    }

    // Used in assert example
    static int getnum() {
        return val--; // return an integer
    }
}